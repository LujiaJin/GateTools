#!/bin/env python3
# -*- coding: utf-8 -*-

import numpy as np
import sys
import os
import uproot
from matplotlib import pyplot as plt

# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

''' ---------------------------------------------------------------------------
Read a PHSP (Phase-Space) file
Output is numpy structured array
'''
def read_phsp(filename):
    b, extension = os.path.splitext(filename)

    if extension == '.root':
        return read_phsp_root(filename)

    if extension == '.raw':
        return read_phsp_raw(filename)

    print('Error, dont know how to open phsp with extension ', extension)
    exit(0)


''' ---------------------------------------------------------------------------
Read a PHSP (Phase-Space) file in root format
Output is numpy structured array
'''
def read_phsp_root(filename):
   # Check if file exist
    if (not os.path.isfile(filename)):
        print("File '"+filename+"' does not exist.")
        exit()

    # Check if this is a root file
    try:
        f = uproot.open(filename)
    except Exception:
        print("File '"+filename+"' cannot be opened, not root file ?")
        exit()


    # Look for a single key named "PhaseSpace"
    k = f.keys()
    try:
        psf = f['PhaseSpace']
    except Exception:
        print("This root file is not a PhaseSpace, keys are: ", f.keys())
        exit()
        psf = f['PhaseSpace']

    # Convert to arrays
    #print("PhaseSpace keys: ", psf.keys())
    #psf.show()
    a = psf.arrays()
    E = a[b'Ekine']
    x = a[b'X']
    y = a[b'Y']
    z = a[b'Z']
    dx = a[b'dX']
    dy = a[b'dY']
    dz = a[b'dZ']

    # test --> TTree not writable yet
    # f = uproot.recreate('toto.root')
    # f['PhaseSpace'] = psf    
    
    w = a[b'Weight']
    uni = np.unique(w)
    print('Check root weight', uni, len(w), len(uni))
    if len(uni) > 1:
        mask = np.where(w == 1.0, 0, 1)
        E = E[mask==1.0]
        x = x[mask==1.0]
        y = y[mask==1.0]
        z = z[mask==1.0]
        dx = dx[mask==1.0]
        dy = dy[mask==1.0]
        dz = dz[mask==1.0]
        print('New size is', len(E))
    
    data = np.column_stack((E, x, y, z, dx, dy, dz))

    return data


''' ---------------------------------------------------------------------------
Read a PHSP (Phase-Space) file in npy
Output is numpy structured array
'''
def read_phsp_npy(filename):
   # Check if file exist
    if (not os.path.isfile(filename)):
        print("File '"+filename+"' does not exist.")
        exit()

    x = np.load(filename)
    data = x.view(np.float32).reshape(x.shape + (-1,))
    data = np.float64(data)
    return data, x.dtype.names


''' ---------------------------------------------------------------------------
Read a PHSP (Phase-Space) file in raw
Output is numpy structured array
'''
def read_phsp_raw(filename):
   # Check if file exist
    if (not os.path.isfile(filename)):
        print("File '"+filename+"' does not exist.")
        exit()

    f = open(filename, "rb")
    bytes_array = f.read()
    dt = np.dtype(np.float32)
    data = np.frombuffer(bytes_array, dtype=dt)
    rn = len(data)/7
    data = np.reshape(data, (int(rn),7))

    return data


''' ---------------------------------------------------------------------------
Write data to npy
'''
def write_to_npy(data, mode, filename):

    p = []
    if mode == 'cylinder_1' or mode == 'cylinder_2':
        r = np.zeros(len(data),
                     dtype=[('E',     'f4'),
                            ('psi',   'f4'),
                            ('z',     'f4'),
                            ('theta', 'f4'),
                            ('phi',   'f4'),])
        r['E'] = data[:,0]
        r['psi'] = data[:,1]
        r['z'] = data[:,2]
        r['theta'] = data[:,3]
        r['phi'] = data[:,4]
        np.save(filename, r)
        return

    if mode == 'plane':
        r = np.zeros(len(data),
                     dtype=[('E',     'f4'),
                            ('x',     'f4'),
                            ('y',     'f4'),
                            ('theta', 'f4'),
                            ('phi',   'f4'),])
        r['E'] = data[:,0]
        r['x'] = data[:,1]
        r['y'] = data[:,2]
        r['theta'] = data[:,3]
        r['phi'] = data[:,4]
        np.save(filename, r)
        return

    if mode == 'cartesian':
        r = np.zeros(len(data),
                     dtype=[('E',   'f4'),
                            ('x',   'f4'),
                            ('y',   'f4'),
                            ('dx',  'f4'),
                            ('dy',  'f4'),
                            ('dz',  'f4'),])
        r['E'] = data[:,0]
        r['x'] = data[:,1]
        r['y'] = data[:,2]
        r['dx'] = data[:,3]
        r['dy'] = data[:,4]
        r['dz'] = data[:,5]
        np.save(filename, r)
        return

    print('error dont know mode', mode, '(cylinder_1 cylinder_2 plane cartesian)')
    exit(0)


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

''' ---------------------------------------------------------------------------
Convert to spherical coordinates according to mode
'''
def cartesian_to_spherical(data, mode, verbose=False):

    f = { 'cylinder_1': cartesian_to_spherical_cylinder_1,
          'cylinder_2': cartesian_to_spherical_cylinder_2,
          'plane': cartesian_to_spherical_plane,
          'cartesian': cartesian_to_spherical_cartesian
    }

    if mode in f:
        return f[mode](data, verbose)

    print('error dont know mode', mode, '(cylinder_1 cylinder_2 plane cartesian)')
    exit(0)


''' ---------------------------------------------------------------------------
Convert to spherical coordinate according to mode
'''
def cartesian_to_spherical_cylinder_1(data, verbose=False):

    E, x, y, z, dx, dy, dz = [data[:,i] for i in np.arange(len(data[0]))]

    radius = np.sqrt(np.power(x,2) + np.power(y, 2))
    if verbose:
        print('radius must be constant: ', radius)
    radius = np.mean(radius)

    psi = np.arctan2(y, x)

    if verbose:
        r = np.sqrt(dx**2 + dy**2 + dz**2)
        print('norm dir must be constant: ', r)

    theta = np.arccos(dz)
    phi = np.arctan2(dy,dx)

    data = np.column_stack((E, psi, z, theta, phi))
    return data

''' ---------------------------------------------------------------------------
Convert to spherical coordinate according to mode
'''
def cartesian_to_spherical_cylinder_2(data, verbose=False):

    data = cartesian_to_spherical_cylinder_1(data, verbose)

    E, psi, z, theta, phi = [data[:,i] for i in np.arange(len(data))]
    phi = (phi-psi+np.pi)%(2*np.pi)-np.pi

    data = np.column_stack((E, psi, z, theta, phi))
    return data

''' ---------------------------------------------------------------------------
Convert to spherical coordinate according to mode
'''
def cartesian_to_spherical_plane(data, verbose=False):

    E, x, y, z, dx, dy, dz = [data[:,i] for i in np.arange(len(data[0]))]

    theta = np.arccos(dz)
    phi = np.arctan2(dy,dx)

    data = np.column_stack((E, x, y, theta, phi))
    return data


''' ---------------------------------------------------------------------------
Convert to spherical coordinate according to mode
'''
def cartesian_to_spherical_cartesian(data, verbose=False):
    E, x, y, z, dx, dy, dz = [data[:,i] for i in np.arange(len(data[0]))]
    data = np.column_stack((E, x, y, dx, dy, dz)) 
    return data


''' ---------------------------------------------------------------------------
Convert from spherical to cartesian coordinates according to mode
'''
def spherical_to_cartesian(data, value, mode, verbose=False):

    f = { 'cylinder_1': spherical_to_cartesian_cylinder_1,
          'cylinder_2': spherical_to_cartesian_cylinder_2,
          'plane': spherical_to_cartesian_plane,
          'cartesian': spherical_to_cartesian_cartesian,}

    if mode in f:
        return f[mode](data, value, verbose)

    print('error dont know mode', mode, '(cylinder_1 cylinder_2 plane cartesian)')
    exit(0)


''' ---------------------------------------------------------------------------
Convert from spherical to cartesian coordinates
'''
def spherical_to_cartesian_cylinder_1(data, radius, verbose=False):

    E, psi, z, theta, phi = [data[:,i] for i in np.arange(len(data[0]))]

    # position
    x = radius*np.cos(psi)
    y = radius*np.sin(psi)

    # convert direction to dx,dy,dz
    dz = np.cos(theta)
    f = np.sin(theta)
    dx = np.cos(phi)
    dy = np.sin(phi)

    # need to noprm by projected vector lenght
    # f = np.sin(theta)
    dy = dy*f
    dx = dx*f

    data = np.column_stack((E, x, y, z, dx, dy, dz))
    return data

''' ---------------------------------------------------------------------------
Convert from spherical to cartesian coordinates
'''
def spherical_to_cartesian_cylinder_2(data, radius, verbose=False):

    E, psi, z, theta, phi = [data[:,i] for i in np.arange(len(data[0]))]

    # position
    x = radius*np.cos(psi)
    y = radius*np.sin(psi)

    # convert direction to dx,dy,dz
    phi = (phi+psi+np.pi)%(2*np.pi)-np.pi
    dz = np.cos(theta)
    f = np.sin(theta)
    dx = np.cos(phi)
    dy = np.sin(phi)

    # need to noprm by projected vector lenght
    # f = np.sin(theta)
    dy = dy*f
    dx = dx*f

    data = np.column_stack((E, x, y, z, dx, dy, dz))
    return data

''' ---------------------------------------------------------------------------
Convert from spherical to cartesian coordinates
'''
def spherical_to_cartesian_plane(data, z_plane, verbose=False):

    E, x, y, theta, phi = [data[:,i] for i in np.arange(len(data[0]))]

    print('spherical_to_cartesian_plane', z_plane)

    # convert direction to dx,dy,dz
    dz = np.cos(theta)
    f = np.sin(theta)
    dx = np.cos(phi)
    dy = np.sin(phi)

    # need to noprm by projected vector lenght
    # f = np.sin(theta)
    dy = dy*f
    dx = dx*f

    z = np.ones(len(x))*z_plane

    data = np.column_stack((E, x, y, z, dx, dy, dz))
    return data


''' ---------------------------------------------------------------------------
Convert from spherical to cartesian coordinates
'''
def spherical_to_cartesian_cartesian(data, z_plane, verbose=False):
    E, x, y, dx, dy, dz = [data[:,i] for i in np.arange(len(data[0]))]
    z = np.ones(len(x))*z_plane
    data = np.column_stack((E, x, y, z, dx, dy, dz))
    return data


# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------


''' ---------------------------------------------------------------------------
Encode all parameters according to the policy
'''
def encode_parameters(x, names, policy):
    ex = np.empty((len(x), 0))
    param_index = {}
    for p in policy:
        a = encode_one_parameter(x, names, p, policy[p])
        ex = np.column_stack((ex, a))
        if policy[p] == 'ignore':
            param_index[p] = -1
        if policy[p] == 'keep':
            param_index[p] = len(ex[0])-1
        if policy[p] == 'sincos':
            param_index[p] = len(ex[0])-2

    return ex, param_index


''' ---------------------------------------------------------------------------
Decode all parameters according to the policy
'''
def decode_parameters(x, names, param_index, policy):
    ex = np.empty((len(x), 0))
    for p in names:
        a = decode_one_parameter(x, param_index[p], p, policy[p])
        ex = np.column_stack((ex, a))

    return ex


''' ---------------------------------------------------------------------------
Encode one parameter according to the policy
'''
def encode_one_parameter(x, names, p, transform):
    try:
        index = names.index(p)
    except:
        print('error dont know parameter', p)
        print('in encode_one_parameter', x.shape, names, p, transform)
        exit(0)

    t = x[:,index]

    if transform == 'ignore':
        return np.array([])

    if transform == 'keep':
        return t

    if transform == 'sincos':
        x1 = np.sin(t)
        x2 = np.cos(t)
        t = np.column_stack((x1, x2))
        return t

    print('error, dont know transform', transform)
    print('in encode_one_parameter', x.shape, names, p, transform)
    exit(0)


''' ---------------------------------------------------------------------------
Decode one parameter according to the policy
'''
def decode_one_parameter(x, index, p, transform):
    if transform == 'ignore':
        return np.array([])

    t = x[:,index]

    if transform == 'keep':
        return t

    if transform == 'sincos':
        x1 = t
        x2 = x[:,index+1]
        a = np.arctan2(x1,x2)
        return a

    print('error, dont know transform', transform)
    print('in decode_one_parameter', x.shape, names, p, transform)
    exit(0)

